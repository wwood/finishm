#!/usr/bin/env ruby

require 'optparse'
require 'bio-logger'
require 'bio-velvet'
require 'pp'

SCRIPT_NAME = File.basename(__FILE__); LOG_NAME = 'finishm'
$:.unshift File.join(File.dirname(__FILE__),'..','lib')
require 'priner'

# Parse command line options into the options hash
options = {
  :logger => 'stderr',
  :log_level => 'info',
}
global = OptionParser.new do |opts|
  opts.banner = "
    Usage: #{SCRIPT_NAME} <command> [<arguments>]

  FinishM is a collection of tasks related to assembly and metagenome assembly. Available commands:

    wander\tTry to connect contigs (experimental)
    gapfill\tFill assembly gaps (N characters) (experimental)
    explore\tWhat happens in the graph beyond the end of my contig(s)? (experimental)
    visualise\tVisualise the DeBruijn graph (experimental)

  Commands for PCR finishing:

    primers\tdesign primers for multi-primer multi-lane PCR experimental setup (experimental)
    primers_check\ttest a set of primers for incompatibility (experimental)
    finish\tprocess results from multi-primer multi-lane PCR experimental setup (experimental)

  Utility modes:

    sequence\tGiven a defined sequence of nodes, what is the corresponding sequence?
    path_count\tCount the number of paths through an assembly
    \n\n"
end
global.order!

operator = nil
subcommands = {
  'primers' => lambda {OptionParser.new do |opts|
    operator = Bio::FinishM::Primers.new
    operator.add_options(opts, options)
  end},
  'primers_check' => lambda {OptionParser.new do |opts|
    operator = Bio::FinishM::Primers::Checker.new
    operator.add_options(opts, options)
  end},
  'finish' => lambda {OptionParser.new do |opts|
    operator = Bio::FinishM::Finisher.new
    operator.add_options(opts, options)
  end},
  'gapfill' => lambda {OptionParser.new do |opts|
    operator = Bio::FinishM::GapFiller.new
    operator.add_options(opts, options)
  end},
  'wander' => lambda {OptionParser.new do |opts|
    operator = Bio::FinishM::Wanderer.new
    operator.add_options(opts, options)
  end},
  'fluff' => lambda {OptionParser.new do |opts|
    operator = Bio::FinishM::Fluff.new
    operator.add_options(opts, options)
  end},
  'explore' => lambda {OptionParser.new do |opts|
    operator = Bio::FinishM::Explorer.new
    operator.add_options(opts, options)
  end},
  'assemble' => lambda {OptionParser.new do |opts|
    operator = Bio::FinishM::Assembler.new
    operator.add_options(opts, options)
  end},
  'visualise' => lambda {OptionParser.new do |opts|
    operator = Bio::FinishM::Visualise.new
    operator.add_options(opts, options)
  end},
  'sequence' => lambda {OptionParser.new do |opts|
    operator = Bio::FinishM::Sequence.new
    operator.add_options(opts, options)
  end},
  'roundup' => lambda {OptionParser.new do |opts|
    operator = Bio::FinishM::RoundUp.new
    operator.add_options(opts, options)
  end},
  'path_count' => lambda {OptionParser.new do |opts|
    operator = Bio::FinishM::PathCounter.new
    operator.add_options(opts, options)
  end}
}

subcommand = nil
if ARGV[0] and ARGV[0].match(/finishm$/) #if debugging e.g. 'pry finishm wander ..'. But be careful of finishm no arguments
  subcommand = ARGV.shift
  subcommand = ARGV.shift
else
  # not debugging
  subcommand = ARGV.shift
end

if subcommand.nil?
  $stderr.puts global
  exit 1
elsif !subcommands[subcommand]
  $stderr.puts "Unrecognized subcommand: #{subcommand}"
  exit 1
else
  # Add options specific for subcommand
  opts = subcommands[subcommand].call

  # Add global logging options
  opts.separator "\nVerbosity:\n\n"
  opts.on("-q", "--quiet", "Run quietly, set logging to ERROR level [default INFO]") {options[:log_level] = 'error'}
  opts.on("--logger filename",String,"Log to file [default #{options[:logger]}]") { |name| options[:logger] = name}
  opts.on("--trace options",String,"Set log level [default INFO]. e.g. '--trace debug' to set logging level to DEBUG"){|s| options[:log_level] = s}
  opts.separator "\n"
  opts.parse!

  # Setup logging
  Bio::Log::CLI.logger(options[:logger]); Bio::Log::CLI.trace(options[:log_level]); log = Bio::Log::LoggerPlus.new(LOG_NAME); Bio::Log::CLI.configure(LOG_NAME); log.outputters.each {|o| o.formatter = Log4r::PatternFormatter.new(:pattern => "%5l %c %d: %m", :date_pattern => '%d/%m %T')}
  Bio::Log::LoggerPlus.new 'bio-velvet'; Bio::Log::CLI.configure 'bio-velvet'

  log.debug "Running FinishM #{subcommand} with these options: #{PP.pp(options, "").gsub(/\n$/,'')}"

  error_message = operator.validate_options(options, ARGV)
  if error_message.nil? or error_message == false
    operator.run options, ARGV
  else
    $stderr.puts
    $stderr.puts "ERROR parsing options: #{error_message}"
    $stderr.puts
    $stderr.puts opts
    exit 1
  end
end

